# <section 4> 스프링 빈과 의존관계

# 📚Topic covered

1. 의존과 의존성
2. @Autowired 의존성 주입
3. DIP
4. 스프링 빈과 스프링 컨테이너란?
5. JDBC와 JPA?

# 📘스프링 빈을 등록하는 2가지 방법

## 1)컴포넌트 스캔(@ComponentName)과 자동 의존관계(@Autowired) 설정

### 🔖컴포넌트 스캔

- new를 사용해서 인스턴스를 사용하지 않고, @ComponentName(Controller, Service, Repository)를 클래스명 위에 선언을 하면 **추상적인 클래스에 강제로 의존성을 주입**할 수 있다.
    
     👉인스턴스를 생성하지 않기 때문에 속도, 메모리 효율성 good
    

### @Autowired 의존성 주입 순서

1. @Controller 컴포넌트가 있는 MemberController 클래스에서 MemberController를 생성자로 만든 다음, memberService를 인스턴스로 초기화하고 @Autowired 시킨다.
2. @Service 컴포넌트가 있는 MemberService 클래스에서 MemberService를 생성자로 만든 다음, memberRepository를 인스턴스로 초기화하고 @Autowired 시킨다.
3. 마지막으로 @Repository 컴포넌트로 Annotation하면 끝!

즉, @Controller, @Service, @Repository로 **컴포넌트 스캔**을 하면, 자동으로 스프링 컨테이너에 스프링 빈(싱글톤 객체)으로 등록하고, 각각의 생성자에 의존 관계가 되는 클래스를 인스턴스로 초기화함으로써 **@Autowired 과정**이 되는 것이다.

🧐참고로, 스프링 빈에 등록된 객체들은 **모두 같은 인스턴스**다(싱글톤)

⚠️**컴포넌트 스캔 과정을 생략**하면, 의존 관계가 주입되는 클래스는 코드 섹션(추상적)에 있으므로 **스프링이 인식 할 수 없음**

![Untitled](section%204%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%87%E1%85%B5%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%2056d3bcf94b0a4ead8adee3dd10674936/Untitled.png)

## 2)자바 코드로 직접 스프링 빈 등록하기

- SpringConfig라는 클래스를 새로 생성하여, **@Configuration**이라는 어노테이션을 선언하고, Service, Repository를 **@Bean**으로 수동으로 등록한다.
    - 의존성이 주입된 클래스를 리턴함으로써 wired 과정이 구현된다.

### 🤔왜 굳이 컴포넌트 스캔과 Autowired를 통해 자동으로 스프링 컨테이너에 등록이 되는데, 이렇게 @Bean으로 수동으로 등록하는 이유가 무엇일까?

- MemberRepository는 **인터페이스로 구현된 가상 시나리오**이기 때문에, 구현체에 해당하는 **MemoryMemberRepository를 상황에 따라DbMemberRepository로 구현 클래스를 변경할 수 있다.**
    - 코드 자체를 수정하지 않고, 구현클래스만 변경하면 되기 때문에, 재사용성에 용이!

## 참고) DI를 주입하는 3가지 방법

1. 필드 주입: 멤버 변수에 어노테이션으로 컴포넌트 스캔을 함으로써 의존성을 주입하는 것을 말함 
    
    💣권장하지 않음!
    
2. setter 주입: setter함수로 컴포넌트 스캔을 하는 과정인데, public으로 노출이 되기 때문에 set으로 설정하고, setter 바디에 임의로 메소드를 작성하여 실행시키면 변경이 되서 문제가 생김
    
    💣 역시 권장 x!
    
3. (강력히 권장) **생성자 주입**: 생성자를 통해서 다른 클래스에 의존성을 주입하는 것을 말한다. 
    
    💰의존관계가 실행중에 동적으로 변하는 경우는 일절 없으므로 권장함
    

# 📘DIP

[💠 완벽하게 이해하는 DIP (의존 역전 원칙)](https://inpa.tistory.com/entry/OOP-💠-아주-쉽게-이해하는-DIP-의존-역전-원칙)

- *의존 역전 원칙(Dependency Inversion Principle)*이라고 하며, 객체에서 어떤 Class를 직접 참조하는 것이 아니라 그 대상의 **상위 요소(추상 클래스 or 인터페이스)로 참조하라는 원칙**이다.
    - 다시 말하면, 추상성이 높은 인터페이스와 통신을 한다는 의미 ← *Polymorphism*과 깊은 연관이 있음!*(one interface, multiple implementations)*
        - 인터페이스의 **무변경 원칙**
    - 이렇게 하면, **하위 모듈들이 변경**되더라도, 클라이언트는 상위 인터페이스와 통신하기 때문에 **연관이 x**

### 🔖구체 클래스(Concrete Class)

- 추상클래스(Abstract Class)와 반대말로, *new* 키워드를 사용하여 인스턴스를 만드는 클래스를 의미한다
    - 인스턴스를 만들 수 있는 클래스는, 달리 말하면 필드에 속성이 없더라도 **의존성을 주입한 클래스를 필드로 사용함으로써 new 키워드로 인스턴스를 만들 수 있다**는 것이다.

- DIP의 핵심적인 원칙은 Concrete module을 의존하는 것이 아닌, **추상적인 high-level 모듈(위에서 말한 인터페이스)에 의존하도록 리팩토링**하라는 것이다.
    - 역시 overriding을 이용해서 하위모듈의 method만 변경하면 되기 때문에 의존성⬇️

# 📘스프링 빈과 스프링 컨테이너란?

### 🔖스프링 빈

- **싱글톤**(스프링 컨테이너에 유일하게 하나만 등록해서 리소스들을 공유)으로 생성된 자바 객체를 의미
- **정형화 되지 않거나**, 상황에 따라 **Concrete Class를 변경**해야 하면 설정을 통해 스프링 빈으로 등록
    - 컨트롤러, 서비스, 리포지토리들은 정형화된 코드이기 때문에 컴포넌트 스캔을 사용

### 🔖스프링 컨테이너

- 자바 객체(스프링 빈)의 생명 주기를 관리하며, 컨테이너가 *IoC*(Inversion of Control, 즉 객체를 제어하고 관리하는 역할이 개발자로부터 **스프링 컨테이너에 역전),** *DI*같은 추가적인 기능을 런타임 과정에서 알아서 함
    - 그러니까, 개발자가 new 키워드, 인터페이스 호출과 같이 직접 객체를 제어하는 것이 아니라는 의미임

# 📘JDBC와 JPA

### 🔖JDBC

- Java DataBase Connectivity로, 자바에서 데이터베이스에 접속하고 쿼리를 짜게 도와주는 API이다
    - 전과 같이 DB가 아닌 메모리 영역에서 쿼리를 짜고 재실행시키면, 영구 저장이 아니기 때문에 데이터가 다 날라감
- DataSource의 객체를 생성하고, 스프링 빈에 등록되면 스프링 컨테이너가 런타임 환경내에서 DI를 주입시켜준다
- 사실상, JDBC는 아주 레거시한 코드이기 때문에, h2 DB 프로그램을 사용해 SQL문을 짜는 경우가 더 많다

![Untitled](section%204%20%E1%84%89%E1%85%B3%E1%84%91%E1%85%B3%E1%84%85%E1%85%B5%E1%86%BC%20%E1%84%87%E1%85%B5%E1%86%AB%E1%84%80%E1%85%AA%20%E1%84%8B%E1%85%B4%E1%84%8C%E1%85%A9%E1%86%AB%E1%84%80%E1%85%AA%E1%86%AB%E1%84%80%E1%85%A8%2056d3bcf94b0a4ead8adee3dd10674936/Untitled%201.png)

### 🔖ORM(Object-Relational Mapping)

- 애플리케이션 클래스와 RDB(Relational DataBase)의 테이블을 매핑한다는 의미
    - 개발자가 쿼리를 안짜도 내부적으로 쿼리를 짜주는 로직이 있기 때문에, **객체지향형 개발**이 가능
    - SQL문이 아닌 메소드를 통해 DB를 조작할 수 있지만, 프로젝트가 커지고 쿼리가 많아지면 다시 SQL문으로 돌아가야하는 상황이 발생

### 🔖JPA(Java Persistence API)

- java에서 ORM 기술 표준을 사용하는 **인터페이스 모음**이라고 보면됨
    - Hibernate, OpenJPA 등이 JPA를 구현
- JPA의 결정적인 역할은 반복적인 CRUD(Create, Read, Update, Delete) SQL문을 작성하고 객체에 매핑하는 **비용을 현저하게 줄여준다**

👉이것 역시, 개발자가 코드 및 쿼리를 짜는 것이 아닌 **객체 모델링에만 집중**하면 되는 방향과 일치