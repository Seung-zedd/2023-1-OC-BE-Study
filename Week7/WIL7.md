# <Chapter 5> SOLID 원칙

# 📚Topic Covered

- 단일 책임 원칙(Single Responsibility Principle)의 개념과 해당 원칙이 적용되었을 때의 장점
- 개방 폐쇄 원칙(Open Closed Principle)의 개념과 해당 원칙이 적용되었을 때의 장점
- 리스코프 치환 원칙(Liskov Substitution Principle)의 개념과 해당 원칙이 적용되었을 때의 장점
- 인터페이스 분리 원칙(Interface Segregation Principle)의 개념과 해당 원칙이 적용되었을 때의 장점
- 의존 역전 원칙(Dependency Inversion Principle)의 개념과 해당 원칙이 적용되었을 때의 장점

### 🔖결합도(Coupling)과 응집도(Cohesion)

- Coupling: 모듈(클래스) 간의 **상호 의존 정도**를 의미
    - Coupling🔽 → Dependency🔽  👈 객체의 재사용성 및 유지보수🔼
- Cohesion: 하나의 모듈 내부에 존재하는 구성 요소(implements)들의 기능적 관련성
    - Cohesion⬆️ 👈 **하나의 책임(a single purpose)**에 집중해서 독립성이 높아짐, 이 역시 재사용성 및 유지보수🔼

결론) **Cohesion을 높이고 Coupling을 낮추면** 재사용성과 유지보수의 용이성은 자동으로 따라온다는 고전 원칙

# 📘 SRP(Single Responsibility Principle) - 단일 책임 원칙

- 단일 책임 원칙이란, 간단하게 **역할(책임)을 분리**하라는 것임
    - 이것도, 위에서 본 Cohesion을 높이라는 고전 원칙을 계승한 것

## 📖클래스에 적용한 SRP 개념

> 어떤 클래스를 변경해야 하는 이유는 **오직 하나**뿐이어야 한다 by 로버트 C. 마틴
> 

먼저, SRP를 적용하지 않은 클래스를 살펴볼껀데, 즉 남자라는 클래스를 만든다음, 여자친구, 어머니, 직장상사, 소대장이 남자클래스에 모두 의존한다(→사용한다)고 가정해보자

- 남자라는 클래스에 각자 역할을 하는 operation들을 때려박으면 당장은 편할 것이다.

### 🤔만약 남자클래스의 어딘가에 버그가 발생하면 어떻게 될까?

 👉위에서 살펴봤듯이, 여러 개의 클래스들이 남자클래스에 의존을 하기 때문에 **Coupling이 높아져 유지보수에 대한 비용이 높아질 것이다**

🍝이것을, 흔히 스파게티 코드(냄새나는 코드)라고 하는데, **여기저기에서 한 클래스에 대해 참조**를 하기 때문에 코드가 꼬인 것처럼 보인다고 해서 이름이 붙여짐

📓우리가 이전에 스프링 입문 강의에서 “의존한다”를 배운 적이 있는데, 이것을 **사용한다**로 치환해서 이해해도 무방하다.

- 즉, “여자친구는 남자친구를 사용한다”, “어머니는 아들을 사용한다”, “직장상사는 사원을 사용한다”… 와 같이 말이다

즉, SRP를 적용하면 다음과 같이 **여러 개의 클래스로 분리**가 된다

1. 여자친구 → 남자친구
2. 직장상사 → 사원
3. 어머니 → 아들
4. 소대장 → 소대원

👉이렇게 역할을 분리하면 Coupling이 낮아졌기 때문에 유지보수 비용을 줄일 수 있다

## 📖속성에 적용한 SRP 개념

### 💻SRP를 지키지 못한 속성에 대한 예시 코드

```java
class 사람 {
	String 군번;
...
}
...

사람 로미오 = new 사람();
사람 로미엣 = new 사람();

줄리엣.군번 = "1573042009"; // 여자인데 군번이 있을 수 x
```

- 이것에 대해, SRP를 지킨 속성에 대한 예시 코드 리팩토링은 다음과 같다

### 💻SRP를 지킨 속성에 대한 예시 코드 리팩토링

```java
class 사람 {
	...
}

class 남자 extends 사람 {
	String 군번;
...
}

class 여자 extends 사람 {
	String 학번;
...
}

사람 로미오 = new 남자();
사람 로미엣 = new 여자();

로미오.군번 = "1573042009"; // OK!
로미엣.군번 = "1573042009"; // Error!
```

장점: Polymorphism을 적용하면, 사람이라는 클래스만으로 남자 객체와 여자 객체를 가리킬 수 있어서 **메모리 낭비를 방지**할 수 있고,  

위와 같이 하나의 클래스에 하나의 역할을 담당하기 때문에 **코드의 가독성도 높아짐**

🧐클래스 뿐만 아니라, DB 테이블에도 *정규화 과정*같이 SRP 개념을 적용한 사례가 있음

## 📖메서드에 적용한 SRP 개념

### 💻SRP를 지키지 못한 메소드에 대한 예시 코드

```java
class 강아지 {
	final static Boolean 수컷 = true;
	final static Boolean 암컷 = false;
Boolean 성별;

void 소변보다() {
	if(this.성별 == 수컷) {
	// 한쪽 다리를 들고 소변을 본다.
}
else {
	// 뒷다리 두 개를 굽혀  앉은 자세로 소변을 본다.
		}
  }
}
```

- 소변보다() 메소드를 수컷, 암컷 두가지로 분기해서 **모두 구현**하려고 했기 때문에 SRP를 위배
    - 대표적인 사례가 위처럼 if문을 무지성으로 사용한 경우

### 💻SRP를 지킨 메소드에 대한 예시 코드 리팩토링

```java
abstract static class 강아지 {
        abstract void 소변보다(); // 바디가 없는 순수 가상 함수
    }

    class 수컷강아지 extends 강아지 {
        @Override
        void 소변보다() {
            // 한쪽 다리를 들고 소변을 본다.
        }
    }

    class 암컷강아지 extends 강아지 {
        @Override
        void 소변보다() {
            // 뒷다리 두 개로 앉은 자세로 소변을 본다.
        }
    }
```

- 이렇게 속성이 없는 가상 클래스는 **순수 가상 함수**를 선언한 다음,  **하위클래스로 오버라이딩**을 시킴으로써 SRP를 지킬 수가 있다

## 😃현실사례에 적용한 SRP 개념

- generalist → specialist, 즉 한 우물만 파자는 의미

## 📖SRP와 연관있는 객체 지향 4대 특성

- 모델링 과정을 담당하는 **추상화**가 app의 경계를 정하고 클래스들을 선별
    - 리팩토링 과정도 SRP를 적용하는 습관을 들이자

# 📘 OCP(Open Closed Principle) - 개방 폐쇄 원칙

> “소프트웨어 엔터티(클래스, 모듈, 함수 등)는 자신의 확장에 대해서는 열려 있어야 하지만 변경(주변의 변화)에 대해서는 닫혀 있어야 한다.”
> 

👉**one interface(super-class), multiple implementations(sub-classes), 이보다 명확한 설명이 있을까?**

- 또한, 이전에 스프링 강의에서 배웠을 때, JDBC에서 김영한 강사님이 *“DB에 해당하는 리포지토리 객체를 필요에 따라 갈아 끼우기만 하면 된다”*고 하였는데, 이것이 바로 OCP를 적용한 것이였다
- 자바에서도 OCP가 적용됬는데, 목적 파일(.class)이 인터페이스(super-class) 역할을 해서 각 운영체제별 JVM에 대해서는 열려있지만, 운영체제의 변화에 대해 닫혀있다

장점: 유연성, 재사용성, 유지보수성 등을 얻을 수 있는데, 결국은 고전 원칙의 장점에 유연성을 더한 것이라 할 수 있다

# 📘 LSP(Liskov Substitution Principle) - 리스코프 치환 원칙

> “서브 타입(derived type)은 언제나 자신의 기반 타입(base type)으로 교체할 수 있어야 한다.”
> 
- 나는 개인적으로 이 문장을 보면서 바로 다형성을 활용한 업캐스팅/다운캐스팅이 바로 떠올랐는데, “교체”에 중점을 뒀기 때문이다
    - 더 자세히 설명하자면, 업캐스팅은 하위 클래스 객체를 상위 클래스 타입으로 변환하는 것을 의미하며, 다운캐스팅은 상위 클래스 타입을 다시 하위 클래스 타입으로 변환하는 것을 의미하는데, 이것 역시 상속 원칙을 적용해서 클래스를 생성했기 때문이다.
    
    ⚠️참고로, **형제 클래스끼리는 형변환이 될 수 없음!**
    

책에서도 **계층도/조직도**로 상속을 적용을 하는 것이 아니라, **분류도**로 상속을 적용하라고 한 것인데, **IS-A관계는 상위클래스의 속성 및 메소드를 상속을 받아 하위클래스로 확장**한 것이기 때문

장점: 

1. **다형성**을 활용했기 때문에, SRP와 같이 기반클래스가 서브클래스를 가리켜서, **추가로 인스턴스를 생성해서 메모리를 낭비할 필요가 없음**
2. **상속**을 적용해서 하위클래스만 추가적으로 만들면 되기 때문에 **모델링의 비용을 줄일 수가 있다**

### 🔖인터페이스의 특징

1. AutoCloseable: 자동으로 닫힐 수 있어야한다(변화에 대한 폐쇄..?)
2. Appendable: 덧붙일 수 있어야함(자신에 대한 확장…?)
3. Cloneable: 복제할 수 있어야함(코드의 재사용성)
4. Runnable: 실행할 수 있어야함(내부모듈의 동작 가능…?)

### 🧐리스코프 치환 원칙에 대한 논문

[리스코프 치환 원칙](https://ko.wikipedia.org/wiki/리스코프_치환_원칙)

이건 시간이 여유로울 때 읽어보자…

# 📘 ISP(Interface Segregation Principle) - 인터페이스 분리 원칙

> “클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다”
> 
- 이전의 SRP는 남자클래스를 예시로 들면서, 여러 개의 클래스로 분할을 했는데 비해, ISP는 굳이 남자클래스를 분할하지 않고 **여러 개의 interface를 만들어서 구현하는 방법**을 말한다

단점: 빈약한 상위 클래스로 만든 ISP를 적용한 코드는 속성, 메소드간의 중복이 있어 커플링이 높아지고, 이것은 다시 의존성을 높이기 때문에 **코드의 재사용성 및 유지보수가 용이하지 x**

👉인터페이스의 최소성 원칙을 기억하자!

장점: 외부에서 특정 인터페이스를 통해 메소드를 호출하기 때문에, 자신이 **사용하지 않는 메소드의 의존 관계를 끊을 수가 있음**

# 📘 DIP(Dependency Inversion Principle) - 의존 역전 원칙

> “고차원 모듈은 저차원 모듈에 의존하면 안 된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.”
> 

> “추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.”
> 

> “자주 변경되는 구체(Concrete) 클래스에 의존하지 마라”
> 
- 예시에서는, 고차원 모듈에 해당하는 추상클래스가 자동차로, 저차원 모듈에 해당하는 구상클래스가 스노우타이어로 되어있는데, **자동차가 스노우타이어에 의존하기 때문에 DIP에 위배**가 된다.
- 또한, **구상클래스인 스노우타이어는 자주 교체**해야 하기 때문에 여기에도 의존하면 안된다

👉따라서, 이것을 DIP가 적용되는 모델링으로 표현하자면, 또다른 추상클래스인 타이어 인터페이스를 만들어서

자동차 → 타이어

스노우타이어 → 타이어

로 의존 관계를 역전시키면 된다. 

장점: OCP(Open Closed Principle)와 마찬가지로, 자주 변경되는 구상클래스만 갈아끼우면 되기 때문에 **추상클래스에 영향을 주지 x**

# 📝정리

- 지금까지 5가지 원칙에 대한 개념과 장점에 대해서 알아보았는데, 이것들 역시 **Cohesion을 높이고 Coupling을 낮추라는** 고전 원칙을 계승한 것이기 때문에 서로 연관이 있음을 알 수 있고 장점이 비슷한 것도 마찬가지

👉SoC(Separation Of Concerns) 또는 single purpose에 초점을 맞춰서 **복잡도가 높은 현실세계를 모델링을 통해 추상화함으로써 복잡도를 낮추는 것이 객체 지향 프로그래밍의 핵심!**